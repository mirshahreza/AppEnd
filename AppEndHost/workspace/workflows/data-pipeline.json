{
  "id": "data-pipeline",
  "name": "Data Pipeline",
  "description": "ETL-like workflow for extracting data, transforming, validating, and loading into target table with error handling and retry logic",
  "version": 1,
  "isPublished": true,
  "variables": [
    {
      "name": "sourceTable",
      "type": "String",
      "value": null
    },
    {
      "name": "targetTable",
      "type": "String",
      "value": null
    },
    {
      "name": "batchSize",
      "type": "Integer",
      "value": 100
    },
    {
      "name": "extractedData",
      "type": "Array",
      "value": []
    },
    {
      "name": "rowsExtracted",
      "type": "Integer",
      "value": 0
    },
    {
      "name": "rowsTransformed",
      "type": "Integer",
      "value": 0
    },
    {
      "name": "rowsValidated",
      "type": "Integer",
      "value": 0
    },
    {
      "name": "rowsLoaded",
      "type": "Integer",
      "value": 0
    },
    {
      "name": "errorCount",
      "type": "Integer",
      "value": 0
    },
    {
      "name": "failedRecords",
      "type": "Array",
      "value": []
    },
    {
      "name": "executionStartTime",
      "type": "DateTime",
      "value": null
    },
    {
      "name": "executionEndTime",
      "type": "DateTime",
      "value": null
    },
    {
      "name": "currentRecord",
      "type": "Object",
      "value": null
    }
  ],
  "inputs": [
    {
      "name": "sourceTable",
      "type": "String",
      "description": "Source table name"
    },
    {
      "name": "targetTable",
      "type": "String",
      "description": "Target table name"
    },
    {
      "name": "batchSize",
      "type": "Integer",
      "description": "Number of rows to process in each batch"
    }
  ],
  "outputs": [
    {
      "name": "totalExtracted",
      "type": "Integer",
      "description": "Total rows extracted from source"
    },
    {
      "name": "totalLoaded",
      "type": "Integer",
      "description": "Total rows successfully loaded"
    },
    {
      "name": "totalErrors",
      "type": "Integer",
      "description": "Total errors encountered"
    },
    {
      "name": "executionDuration",
      "type": "String",
      "description": "Total execution time"
    },
    {
      "name": "success",
      "type": "Boolean",
      "description": "Whether pipeline completed successfully"
    }
  ],
  "root": {
    "type": "Sequence",
    "activities": [
      {
        "id": "log-start",
        "type": "WriteLine",
        "text": "{{ \u0027Starting data pipeline: \u0027 \u002B Input.sourceTable \u002B \u0027 -\u003E \u0027 \u002B Input.targetTable \u002B \u0027, Batch size: \u0027 \u002B Input.batchSize }}",
        "displayName": "Log Pipeline Start"
      },
      {
        "id": "set-start-time",
        "type": "SetVariable",
        "variableName": "executionStartTime",
        "value": "{{ new Date() }}",
        "displayName": "Set Start Time"
      },
      {
        "id": "set-input-vars",
        "type": "Sequence",
        "displayName": "Set Input Variables",
        "activities": [
          {
            "id": "set-source",
            "type": "SetVariable",
            "variableName": "sourceTable",
            "value": "{{ Input.sourceTable }}",
            "displayName": "Set Source Table"
          },
          {
            "id": "set-target",
            "type": "SetVariable",
            "variableName": "targetTable",
            "value": "{{ Input.targetTable }}",
            "displayName": "Set Target Table"
          },
          {
            "id": "set-batch",
            "type": "SetVariable",
            "variableName": "batchSize",
            "value": "{{ Input.batchSize }}",
            "displayName": "Set Batch Size"
          }
        ]
      },
      {
        "id": "validate-source",
        "type": "RunJavaScript",
        "script": "// Step 1: Validate source table exists and has data\nvar dbConf = AppEndDbIO.DbConf.FromSettings(\u0027DefaultRepo\u0027);\nvar conn = dbConf.GetConnection();\ntry {\n  var cmd = conn.CreateCommand();\n  cmd.CommandText = \u0027SELECT COUNT(*) FROM \u0027 \u002B Variables.sourceTable;\n  var count = cmd.ExecuteScalar();\n  Variables.rowsExtracted = count;\n  AppEndCommon.LogMan.LogConsole(\u0027Source validation: \u0027 \u002B count \u002B \u0027 records found in \u0027 \u002B Variables.sourceTable);\n  return { valid: true, count: count };\n} catch (ex) {\n  AppEndCommon.LogMan.LogError(\u0027Source validation failed: \u0027 \u002B ex.Message);\n  return { valid: false, error: ex.Message };\n} finally {\n  conn.Close();\n}",
        "displayName": "Validate Source Table"
      },
      {
        "id": "check-has-data",
        "type": "If",
        "condition": "{{ Variables.rowsExtracted == 0 }}",
        "displayName": "Check If Source Has Data",
        "then": {
          "type": "Sequence",
          "activities": [
            {
              "id": "log-no-data",
              "type": "WriteLine",
              "text": "{{ \u0027No data to process in source table: \u0027 \u002B Variables.sourceTable }}",
              "displayName": "Log No Data"
            },
            {
              "id": "complete-empty",
              "type": "Finish",
              "displayName": "Complete with No Data"
            }
          ]
        }
      },
      {
        "id": "extract-data",
        "type": "RunJavaScript",
        "script": "// Step 2: Extract batch of records from source\nvar dbConf = AppEndDbIO.DbConf.FromSettings(\u0027DefaultRepo\u0027);\nvar conn = dbConf.GetConnection();\ntry {\n  var cmd = conn.CreateCommand();\n  cmd.CommandText = \u0027SELECT TOP \u0027 \u002B Variables.batchSize \u002B \u0027 * FROM \u0027 \u002B Variables.sourceTable;\n  var reader = cmd.ExecuteReader();\n  var records = [];\n  while (reader.Read()) {\n    var record = {};\n    for (var i = 0; i \u003C reader.FieldCount; i\u002B\u002B) {\n      record[reader.GetName(i)] = reader.GetValue(i);\n    }\n    records.push(record);\n  }\n  Variables.extractedData = records;\n  Variables.rowsExtracted = records.length;\n  AppEndCommon.LogMan.LogConsole(\u0027Extracted \u0027 \u002B records.length \u002B \u0027 records from source\u0027);\n  return { extracted: true, count: records.length };\n} catch (ex) {\n  AppEndCommon.LogMan.LogError(\u0027Extraction failed: \u0027 \u002B ex.Message);\n  return { extracted: false, error: ex.Message };\n} finally {\n  reader?.Close();\n  conn.Close();\n}",
        "displayName": "Extract Data from Source"
      },
      {
        "id": "process-records",
        "type": "ForEach",
        "items": "{{ Variables.extractedData }}",
        "displayName": "Process Each Record",
        "body": {
          "type": "Sequence",
          "activities": [
            {
              "id": "set-current-record",
              "type": "SetVariable",
              "variableName": "currentRecord",
              "value": "{{ CurrentValue }}",
              "displayName": "Set Current Record"
            },
            {
              "id": "try-process",
              "type": "TryCatch",
              "displayName": "Try Process Record",
              "try": {
                "type": "Sequence",
                "activities": [
                  {
                    "id": "transform-record",
                    "type": "RunJavaScript",
                    "script": "// Step 3a: Transform record (apply business logic)\nvar record = Variables.currentRecord;\n// Example transformation: normalize strings, validate fields, etc.\nrecord.ProcessedAt = new Date();\nrecord.Status = \u0027Processed\u0027;\nVariables.currentRecord = record;\nVariables.rowsTransformed\u002B\u002B;\nreturn { transformed: true };",
                    "displayName": "Transform Record"
                  },
                  {
                    "id": "validate-record",
                    "type": "RunJavaScript",
                    "script": "// Step 3b: Validate record\nvar record = Variables.currentRecord;\nvar isValid = true;\nvar errors = [];\n// Example validation: check required fields\nif (!record.Id) { isValid = false; errors.push(\u0027Missing Id\u0027); }\nif (!record.Name) { isValid = false; errors.push(\u0027Missing Name\u0027); }\nif (isValid) {\n  Variables.rowsValidated\u002B\u002B;\n  return { valid: true };\n} else {\n  throw new Error(\u0027Validation failed: \u0027 \u002B errors.join(\u0027, \u0027));\n}",
                    "displayName": "Validate Record"
                  },
                  {
                    "id": "load-record",
                    "type": "RunJavaScript",
                    "script": "// Step 3c: Load record into target table\nvar record = Variables.currentRecord;\nvar dbConf = AppEndDbIO.DbConf.FromSettings(\u0027DefaultRepo\u0027);\nvar conn = dbConf.GetConnection();\ntry {\n  var cmd = conn.CreateCommand();\n  cmd.CommandText = \u0027INSERT INTO \u0027 \u002B Variables.targetTable \u002B \u0027 (Id, Name, ProcessedAt, Status) VALUES (@Id, @Name, @ProcessedAt, @Status)\u0027;\n  // Add parameters (pseudo-code)\n  cmd.ExecuteNonQuery();\n  Variables.rowsLoaded\u002B\u002B;\n  return { loaded: true };\n} catch (ex) {\n  throw new Error(\u0027Load failed: \u0027 \u002B ex.Message);\n} finally {\n  conn.Close();\n}",
                    "displayName": "Load Record into Target"
                  }
                ]
              },
              "catch": {
                "type": "Sequence",
                "activities": [
                  {
                    "id": "handle-error",
                    "type": "RunJavaScript",
                    "script": "// Step 3d: Handle error - log failed record\nvar record = Variables.currentRecord;\nvar error = Exception?.Message || \u0027Unknown error\u0027;\nVariables.failedRecords.push({ record: record, error: error, timestamp: new Date() });\nVariables.errorCount\u002B\u002B;\nAppEndCommon.LogMan.LogError(\u0027Failed to process record: \u0027 \u002B JSON.stringify(record) \u002B \u0027, Error: \u0027 \u002B error);\nreturn { errorLogged: true };",
                    "displayName": "Log Failed Record"
                  }
                ]
              }
            }
          ]
        }
      },
      {
        "id": "set-end-time",
        "type": "SetVariable",
        "variableName": "executionEndTime",
        "value": "{{ new Date() }}",
        "displayName": "Set End Time"
      },
      {
        "id": "build-summary",
        "type": "RunJavaScript",
        "script": "// Step 4: Build summary report\nvar startTime = new Date(Variables.executionStartTime);\nvar endTime = new Date(Variables.executionEndTime);\nvar duration = (endTime - startTime) / 1000; // seconds\nvar durationStr = duration \u002B \u0027s\u0027;\nvar summary = {\n  sourceTable: Variables.sourceTable,\n  targetTable: Variables.targetTable,\n  totalExtracted: Variables.rowsExtracted,\n  totalTransformed: Variables.rowsTransformed,\n  totalValidated: Variables.rowsValidated,\n  totalLoaded: Variables.rowsLoaded,\n  totalErrors: Variables.errorCount,\n  executionDuration: durationStr,\n  success: Variables.errorCount == 0,\n  startTime: startTime,\n  endTime: endTime\n};\nAppEndCommon.LogMan.LogConsole(\u0027Pipeline summary: \u0027 \u002B JSON.stringify(summary));\nreturn summary;",
        "displayName": "Build Summary Report"
      },
      {
        "id": "log-failed-records",
        "type": "If",
        "condition": "{{ Variables.errorCount \u003E 0 }}",
        "displayName": "Check If Errors Occurred",
        "then": {
          "type": "Sequence",
          "activities": [
            {
              "id": "log-errors",
              "type": "RunJavaScript",
              "script": "// Log failed records to database\nvar dbConf = AppEndDbIO.DbConf.FromSettings(\u0027DefaultRepo\u0027);\nvar conn = dbConf.GetConnection();\ntry {\n  Variables.failedRecords.forEach(function(failed) {\n    var cmd = conn.CreateCommand();\n    cmd.CommandText = \u0027INSERT INTO WorkflowErrorLog (WorkflowId, RecordData, ErrorMessage, Timestamp) VALUES (@workflowId, @recordData, @errorMessage, @timestamp)\u0027;\n    // Add parameters and execute\n    cmd.ExecuteNonQuery();\n  });\n  return { errorsLogged: true };\n} catch (ex) {\n  AppEndCommon.LogMan.LogError(\u0027Failed to log errors: \u0027 \u002B ex.Message);\n  return { errorsLogged: false };\n} finally {\n  conn.Close();\n}",
              "displayName": "Log Failed Records to Database"
            },
            {
              "id": "log-error-summary",
              "type": "WriteLine",
              "text": "{{ \u0027WARNING: \u0027 \u002B Variables.errorCount \u002B \u0027 records failed during processing. Check WorkflowErrorLog table.\u0027 }}",
              "displayName": "Log Error Summary"
            }
          ]
        }
      },
      {
        "id": "set-output-extracted",
        "type": "SetOutput",
        "outputName": "totalExtracted",
        "value": "{{ Variables.rowsExtracted }}",
        "displayName": "Set Output Extracted"
      },
      {
        "id": "set-output-loaded",
        "type": "SetOutput",
        "outputName": "totalLoaded",
        "value": "{{ Variables.rowsLoaded }}",
        "displayName": "Set Output Loaded"
      },
      {
        "id": "set-output-errors",
        "type": "SetOutput",
        "outputName": "totalErrors",
        "value": "{{ Variables.errorCount }}",
        "displayName": "Set Output Errors"
      },
      {
        "id": "set-output-duration",
        "type": "SetOutput",
        "outputName": "executionDuration",
        "value": "{{ ((new Date(Variables.executionEndTime) - new Date(Variables.executionStartTime)) / 1000) \u002B \u0027s\u0027 }}",
        "displayName": "Set Output Duration"
      },
      {
        "id": "set-output-success",
        "type": "SetOutput",
        "outputName": "success",
        "value": "{{ Variables.errorCount == 0 }}",
        "displayName": "Set Output Success"
      },
      {
        "id": "log-complete",
        "type": "WriteLine",
        "text": "{{ \u0027Data pipeline completed. Extracted: \u0027 \u002B Variables.rowsExtracted \u002B \u0027, Loaded: \u0027 \u002B Variables.rowsLoaded \u002B \u0027, Errors: \u0027 \u002B Variables.errorCount }}",
        "displayName": "Log Pipeline Completion"
      }
    ]
  }
}