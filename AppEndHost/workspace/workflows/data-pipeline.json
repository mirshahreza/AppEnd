{
  "id": "data-pipeline",
  "name": "Data Pipeline",
  "description": "ETL-like workflow for extracting data, transforming, validating, and loading into target table with error handling and retry logic",
  "version": 1,
  "isPublished": true,
  "variables": [
    {
      "name": "sourceTable",
      "type": "String",
      "value": null
    },
    {
      "name": "targetTable",
      "type": "String",
      "value": null
    },
    {
      "name": "batchSize",
      "type": "Integer",
      "value": 100
    },
    {
      "name": "extractedData",
      "type": "Array",
      "value": []
    },
    {
      "name": "rowsExtracted",
      "type": "Integer",
      "value": 0
    },
    {
      "name": "rowsTransformed",
      "type": "Integer",
      "value": 0
    },
    {
      "name": "rowsValidated",
      "type": "Integer",
      "value": 0
    },
    {
      "name": "rowsLoaded",
      "type": "Integer",
      "value": 0
    },
    {
      "name": "errorCount",
      "type": "Integer",
      "value": 0
    },
    {
      "name": "failedRecords",
      "type": "Array",
      "value": []
    },
    {
      "name": "executionStartTime",
      "type": "DateTime",
      "value": null
    },
    {
      "name": "executionEndTime",
      "type": "DateTime",
      "value": null
    },
    {
      "name": "currentRecord",
      "type": "Object",
      "value": null
    }
  ],
  "inputs": [
    {
      "name": "sourceTable",
      "type": "String",
      "description": "Source table name"
    },
    {
      "name": "targetTable",
      "type": "String",
      "description": "Target table name"
    },
    {
      "name": "batchSize",
      "type": "Integer",
      "description": "Number of rows to process in each batch"
    }
  ],
  "outputs": [
    {
      "name": "totalExtracted",
      "type": "Integer",
      "description": "Total rows extracted from source"
    },
    {
      "name": "totalLoaded",
      "type": "Integer",
      "description": "Total rows successfully loaded"
    },
    {
      "name": "totalErrors",
      "type": "Integer",
      "description": "Total errors encountered"
    },
    {
      "name": "executionDuration",
      "type": "String",
      "description": "Total execution time"
    },
    {
      "name": "success",
      "type": "Boolean",
      "description": "Whether pipeline completed successfully"
    }
  ],
  "root": {
    "type": "Sequence",
    "activities": [
      {
        "id": "log-start",
        "type": "WriteLine",
        "text": "{{ 'Starting data pipeline: ' + Input.sourceTable + ' -> ' + Input.targetTable + ', Batch size: ' + Input.batchSize }}",
        "displayName": "Log Pipeline Start"
      },
      {
        "id": "set-start-time",
        "type": "SetVariable",
        "variableName": "executionStartTime",
        "value": "{{ new Date() }}",
        "displayName": "Set Start Time"
      },
      {
        "id": "set-input-vars",
        "type": "Sequence",
        "displayName": "Set Input Variables",
        "activities": [
          {
            "id": "set-source",
            "type": "SetVariable",
            "variableName": "sourceTable",
            "value": "{{ Input.sourceTable }}",
            "displayName": "Set Source Table"
          },
          {
            "id": "set-target",
            "type": "SetVariable",
            "variableName": "targetTable",
            "value": "{{ Input.targetTable }}",
            "displayName": "Set Target Table"
          },
          {
            "id": "set-batch",
            "type": "SetVariable",
            "variableName": "batchSize",
            "value": "{{ Input.batchSize }}",
            "displayName": "Set Batch Size"
          }
        ]
      },
      {
        "id": "validate-source",
        "type": "RunJavaScript",
        "script": "// Step 1: Validate source table exists and has data\nvar dbConf = AppEndDbIO.DbConf.FromSettings('DefaultRepo');\nvar conn = dbConf.GetConnection();\ntry {\n  var cmd = conn.CreateCommand();\n  cmd.CommandText = 'SELECT COUNT(*) FROM ' + Variables.sourceTable;\n  var count = cmd.ExecuteScalar();\n  Variables.rowsExtracted = count;\n  AppEndCommon.LogMan.LogConsole('Source validation: ' + count + ' records found in ' + Variables.sourceTable);\n  return { valid: true, count: count };\n} catch (ex) {\n  AppEndCommon.LogMan.LogError('Source validation failed: ' + ex.Message);\n  return { valid: false, error: ex.Message };\n} finally {\n  conn.Close();\n}",
        "displayName": "Validate Source Table"
      },
      {
        "id": "check-has-data",
        "type": "If",
        "condition": "{{ Variables.rowsExtracted == 0 }}",
        "displayName": "Check If Source Has Data",
        "then": {
          "type": "Sequence",
          "activities": [
            {
              "id": "log-no-data",
              "type": "WriteLine",
              "text": "{{ 'No data to process in source table: ' + Variables.sourceTable }}",
              "displayName": "Log No Data"
            },
            {
              "id": "complete-empty",
              "type": "Finish",
              "displayName": "Complete with No Data"
            }
          ]
        }
      },
      {
        "id": "extract-data",
        "type": "RunJavaScript",
        "script": "// Step 2: Extract batch of records from source\nvar dbConf = AppEndDbIO.DbConf.FromSettings('DefaultRepo');\nvar conn = dbConf.GetConnection();\ntry {\n  var cmd = conn.CreateCommand();\n  cmd.CommandText = 'SELECT TOP ' + Variables.batchSize + ' * FROM ' + Variables.sourceTable;\n  var reader = cmd.ExecuteReader();\n  var records = [];\n  while (reader.Read()) {\n    var record = {};\n    for (var i = 0; i < reader.FieldCount; i++) {\n      record[reader.GetName(i)] = reader.GetValue(i);\n    }\n    records.push(record);\n  }\n  Variables.extractedData = records;\n  Variables.rowsExtracted = records.length;\n  AppEndCommon.LogMan.LogConsole('Extracted ' + records.length + ' records from source');\n  return { extracted: true, count: records.length };\n} catch (ex) {\n  AppEndCommon.LogMan.LogError('Extraction failed: ' + ex.Message);\n  return { extracted: false, error: ex.Message };\n} finally {\n  reader?.Close();\n  conn.Close();\n}",
        "displayName": "Extract Data from Source"
      },
      {
        "id": "process-records",
        "type": "ForEach",
        "items": "{{ Variables.extractedData }}",
        "displayName": "Process Each Record",
        "body": {
          "type": "Sequence",
          "activities": [
            {
              "id": "set-current-record",
              "type": "SetVariable",
              "variableName": "currentRecord",
              "value": "{{ CurrentValue }}",
              "displayName": "Set Current Record"
            },
            {
              "id": "try-process",
              "type": "TryCatch",
              "displayName": "Try Process Record",
              "try": {
                "type": "Sequence",
                "activities": [
                  {
                    "id": "transform-record",
                    "type": "RunJavaScript",
                    "script": "// Step 3a: Transform record (apply business logic)\nvar record = Variables.currentRecord;\n// Example transformation: normalize strings, validate fields, etc.\nrecord.ProcessedAt = new Date();\nrecord.Status = 'Processed';\nVariables.currentRecord = record;\nVariables.rowsTransformed++;\nreturn { transformed: true };",
                    "displayName": "Transform Record"
                  },
                  {
                    "id": "validate-record",
                    "type": "RunJavaScript",
                    "script": "// Step 3b: Validate record\nvar record = Variables.currentRecord;\nvar isValid = true;\nvar errors = [];\n// Example validation: check required fields\nif (!record.Id) { isValid = false; errors.push('Missing Id'); }\nif (!record.Name) { isValid = false; errors.push('Missing Name'); }\nif (isValid) {\n  Variables.rowsValidated++;\n  return { valid: true };\n} else {\n  throw new Error('Validation failed: ' + errors.join(', '));\n}",
                    "displayName": "Validate Record"
                  },
                  {
                    "id": "load-record",
                    "type": "RunJavaScript",
                    "script": "// Step 3c: Load record into target table\nvar record = Variables.currentRecord;\nvar dbConf = AppEndDbIO.DbConf.FromSettings('DefaultRepo');\nvar conn = dbConf.GetConnection();\ntry {\n  var cmd = conn.CreateCommand();\n  cmd.CommandText = 'INSERT INTO ' + Variables.targetTable + ' (Id, Name, ProcessedAt, Status) VALUES (@Id, @Name, @ProcessedAt, @Status)';\n  // Add parameters (pseudo-code)\n  cmd.ExecuteNonQuery();\n  Variables.rowsLoaded++;\n  return { loaded: true };\n} catch (ex) {\n  throw new Error('Load failed: ' + ex.Message);\n} finally {\n  conn.Close();\n}",
                    "displayName": "Load Record into Target"
                  }
                ]
              },
              "catch": {
                "type": "Sequence",
                "activities": [
                  {
                    "id": "handle-error",
                    "type": "RunJavaScript",
                    "script": "// Step 3d: Handle error - log failed record\nvar record = Variables.currentRecord;\nvar error = Exception?.Message || 'Unknown error';\nVariables.failedRecords.push({ record: record, error: error, timestamp: new Date() });\nVariables.errorCount++;\nAppEndCommon.LogMan.LogError('Failed to process record: ' + JSON.stringify(record) + ', Error: ' + error);\nreturn { errorLogged: true };",
                    "displayName": "Log Failed Record"
                  }
                ]
              }
            }
          ]
        }
      },
      {
        "id": "set-end-time",
        "type": "SetVariable",
        "variableName": "executionEndTime",
        "value": "{{ new Date() }}",
        "displayName": "Set End Time"
      },
      {
        "id": "build-summary",
        "type": "RunJavaScript",
        "script": "// Step 4: Build summary report\nvar startTime = new Date(Variables.executionStartTime);\nvar endTime = new Date(Variables.executionEndTime);\nvar duration = (endTime - startTime) / 1000; // seconds\nvar durationStr = duration + 's';\nvar summary = {\n  sourceTable: Variables.sourceTable,\n  targetTable: Variables.targetTable,\n  totalExtracted: Variables.rowsExtracted,\n  totalTransformed: Variables.rowsTransformed,\n  totalValidated: Variables.rowsValidated,\n  totalLoaded: Variables.rowsLoaded,\n  totalErrors: Variables.errorCount,\n  executionDuration: durationStr,\n  success: Variables.errorCount == 0,\n  startTime: startTime,\n  endTime: endTime\n};\nAppEndCommon.LogMan.LogConsole('Pipeline summary: ' + JSON.stringify(summary));\nreturn summary;",
        "displayName": "Build Summary Report"
      },
      {
        "id": "log-failed-records",
        "type": "If",
        "condition": "{{ Variables.errorCount > 0 }}",
        "displayName": "Check If Errors Occurred",
        "then": {
          "type": "Sequence",
          "activities": [
            {
              "id": "log-errors",
              "type": "RunJavaScript",
              "script": "// Log failed records to database\nvar dbConf = AppEndDbIO.DbConf.FromSettings('DefaultRepo');\nvar conn = dbConf.GetConnection();\ntry {\n  Variables.failedRecords.forEach(function(failed) {\n    var cmd = conn.CreateCommand();\n    cmd.CommandText = 'INSERT INTO WorkflowErrorLog (WorkflowId, RecordData, ErrorMessage, Timestamp) VALUES (@workflowId, @recordData, @errorMessage, @timestamp)';\n    // Add parameters and execute\n    cmd.ExecuteNonQuery();\n  });\n  return { errorsLogged: true };\n} catch (ex) {\n  AppEndCommon.LogMan.LogError('Failed to log errors: ' + ex.Message);\n  return { errorsLogged: false };\n} finally {\n  conn.Close();\n}",
              "displayName": "Log Failed Records to Database"
            },
            {
              "id": "log-error-summary",
              "type": "WriteLine",
              "text": "{{ 'WARNING: ' + Variables.errorCount + ' records failed during processing. Check WorkflowErrorLog table.' }}",
              "displayName": "Log Error Summary"
            }
          ]
        }
      },
      {
        "id": "set-output-extracted",
        "type": "SetOutput",
        "outputName": "totalExtracted",
        "value": "{{ Variables.rowsExtracted }}",
        "displayName": "Set Output Extracted"
      },
      {
        "id": "set-output-loaded",
        "type": "SetOutput",
        "outputName": "totalLoaded",
        "value": "{{ Variables.rowsLoaded }}",
        "displayName": "Set Output Loaded"
      },
      {
        "id": "set-output-errors",
        "type": "SetOutput",
        "outputName": "totalErrors",
        "value": "{{ Variables.errorCount }}",
        "displayName": "Set Output Errors"
      },
      {
        "id": "set-output-duration",
        "type": "SetOutput",
        "outputName": "executionDuration",
        "value": "{{ ((new Date(Variables.executionEndTime) - new Date(Variables.executionStartTime)) / 1000) + 's' }}",
        "displayName": "Set Output Duration"
      },
      {
        "id": "set-output-success",
        "type": "SetOutput",
        "outputName": "success",
        "value": "{{ Variables.errorCount == 0 }}",
        "displayName": "Set Output Success"
      },
      {
        "id": "log-complete",
        "type": "WriteLine",
        "text": "{{ 'Data pipeline completed. Extracted: ' + Variables.rowsExtracted + ', Loaded: ' + Variables.rowsLoaded + ', Errors: ' + Variables.errorCount }}",
        "displayName": "Log Pipeline Completion"
      }
    ]
  }
}
